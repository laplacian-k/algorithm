#include <iostream>
using namespace std;

// variables
int N, M;
int r, c;
int d;
int a[50][50];
// 왼쪽 방향을 하나씩 만듦.
//북(0) 동(1) 남(2) 서(3)
const int dir[4][4] = {
    {3, 2, 1, 0},    // 북
    {0, 3, 2, 1},    // 동
    {1, 0, 3, 2},    // 남
    {2, 1, 0, 3}     // 서
};

// 바라보는 방향, 상하좌우 좌표
const int dy[4][4] = {
    {-1, 1, 0, 0},    // 북
    {0, 0, -1, 1},    // 동
    {1, -1, 0, 0},    // 남
    {0, 0, 1, -1}     // 서
};
const int dx[4][4] = {
    {0, 0, -1, 1},    // 북
    {1, -1, 0, 0},    // 동
    {0, 0, 1, -1},    // 남
    {-1, 1, 0, 0}     // 서
};

int main()
{
	// input
	cin >> N >> M;
	cin >> r >> c >> d;
	for (int i = 0; i < N; i++) {
		for (int j = 0; j < M; j++) {
			cin >> a[i][j];
		}
	}

	// algorithm
	// 빈칸(0) 벽(1) 청소한 공간(2)
	// 로봇이 바라보는 방향 북(0) 동(1) 남(2) 서(3)
	// 지금 바라보고 있는 방향 기준 왼쪽방향부터 차례대로 탐색. (앞을 보고있다면 앞을 본 상태에서 왼쪽을 탐색)
	// 1. 현재 위치를 청소한다.
    // 2. 현재 위치에서 현재 방향을 기준으로 왼쪽방향부터 차례대로 탐색을 진행한다.
    //    왼쪽 방향에 아직 청소하지 않은 공간이 존재한다면, 그 방향으로 회전한 다음 한 칸을 전진하고 1번부터 진행한다.
    //    왼쪽 방향에 청소할 방향이 없다면, 그 방향으로 회전하고 2번으로 돌아간다.
    //    네 방향 모두 청소가 이미 되어있거나 벽인 경우에는, 바라보는 방향을 유지한 채로 한 칸 후진을 하고 2번으로 돌아간다.
    //    네 방향 모두 청소가 이미 되어있거나 벽이면서, 뒤쪽 방향이 벽이라 후진도 할 수 없는 경우에는 작동을 멈춘다.
	// 로봇 청소기는 이미 청소되어있는 칸을 또 청소하지 않으며, 벽을 통과할 수 없다.
    int ret = 0;
    int y = r;
    int x = c;
    while(1)
    {
        // 중복 청소는 허용되지 않음.
        if(a[y][x] != 2) ret++;
        // 현재 위치를 청소
        a[y][x] = 2;
        
        
        bool canGo = false;
        // 왼쪽방향부터 차례대로 탐색
        for(int i = 0; i < 4; i++) {
            // 왼쪽 방향을 하나씩 만듦.
            int nd = dir[d][i];
            
            // next 좌표를 만듦
            int ny = y+dy[nd][0];
            int nx = x+dx[nd][0];
            // 좌표공간을 벗어나면 벽으로 간주.
            if(!((0 <= ny && ny < N) && (0 <= nx && nx < N)))
                continue;
            // 청소할 공간이 있다면
            if(a[ny][nx] == 0) {
                // 그 방향으로 회전
                d = nd;
                // 한 칸 전진
                y = ny;
                x = nx;
                canGo = true;
                break;
            }
        }
        
        // 네 방향 모두 청소가 이미 되어있거나 벽인 경우
        if(!canGo) {
            // 뒤쪽 방향을 만듦.
            int ny = y+dy[d][1];
            int nx = x+dx[d][1];
            // 뒤쪽 방향이 벽이라 후진도 할 수 없는 경우에는 작동을 멈춘다.
            if(!((0 <= ny && ny < N) && (0 <= nx && nx < N)) || a[ny][nx] == 1)
                break;
            // 바라보는 방향을 유지한 채로 한 칸 후진
            y = ny;
            x = nx;
        }
    }	
	
	cout << ret << endl;
}
