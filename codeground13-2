#include <iostream>

using namespace std;
int N;

bool makeUniform(int b)
{
    // 1. 모듈러 연산을 한번만해서 b진법의 첫째 자리 수를 구한다. (b^0에 위치하는 수)
    // 2. 가능한 최대 자리까지 1에서 구한 수를 사용해서 숫자를 만든다.
    // 3. N과 2번에서 만든 수를 비교한다.
    // 더 빠르게 하려면 ? 균일수 계산의 형태는 fir*(1+b+b^2+...)
    
    int fir = N%b;
    
    // 1의 결과가 0이면 균일수가 될 수 없음. N != 0
    if(fir == 0)
        return false;
  
    // N%fir가 0이면 균일수 N=fir*(1+b+b^2+...)
    //if(N != 1 && N%fir == 0)
    //    return true;
    //else
    //    return false;
    // fir로 나눠 떨어질뿐만 아니라 fir로 나눠질때 N/fir가 1+b+...+b^n-1꼴로 표현이 되야 함!
         
    int base = b;
    int sum = fir;
    for( ; ; ) {
        sum += base*fir;
        
        // 균일수임을 발견한다면
        if(N == sum)
            return true;
        // 균일수가 될 수 없음.
        if(N < sum)
            return false;
            
        base *= b;
    }
}

int main(int argc, char** argv)
{
	int T, test_case;
	
	cin >> T;
	for(test_case = 0; test_case  < T; test_case++)
	{
	    // input
	    cin >> N;
	    
	    int ret = N+1;    // 문제정의에 따라 자연수 N이 균일수가 되는 최대 양수 b의 최대값은 N+1임.
	    
	    // 기저를 최소부터 늘려가면서 가장 최소의 기저를 찾음
	    // 자연수 N < 기저 b일 경우 b진법으로 1자리수가 되는데 이때에도 균일수로 판단한다.
	    // b는 2이상의 양의 정수!
	    // O(N)에 대해 N이 10^9이므로 time limit 가능성 존재.
	    // 이분탐색 불가.
	    
	    for(int b = 2; b < N; b++) {
	        // 균일수로 판단이 가능하면 정답 발생.
	        if(makeUniform(b)) {
	            ret = b;
	            break;
	        }
	            
	    } 
	    
	    
		cout << "Case #" << test_case+1 << endl;
		cout << ret << endl;
	}

	return 0;//Your program should return 0 on normal termination.
}
